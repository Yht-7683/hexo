<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Redis学习之路 | Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Redis的数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习之路">
<meta property="og:url" content="http://www.2333nmsl.ml/2020/08/14/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis的数据结构">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-14T15:21:33.000Z">
<meta property="article:modified_time" content="2020-08-21T09:18:12.092Z">
<meta property="article:author" content="yht">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.0.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/1.gif" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Yht-7683/" title="github">github</a>
					        
								<a class="mail" target="_blank" href="#" title="mail">mail</a>
					        
								<a class="qq" target="_blank" href="https://wpa.qq.com/msgrd?v=3&uin=434807683&site=qq&menu=yes" title="qq">qq</a>
					        
								<a class="weibo" target="_blank" href="https://weibo.com/" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ASCII%E7%A0%81%E5%9B%BE/" style="font-size: 10px;">ASCII码图</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 20px;">Java基础</a> <a href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">Java多线程</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://a-cai.gitee.io/blog/">前端资料</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/1.gif" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Yht-7683/" title="github">github</a>
			        
						<a class="mail" target="_blank" href="#" title="mail">mail</a>
			        
						<a class="qq" target="_blank" href="https://wpa.qq.com/msgrd?v=3&uin=434807683&site=qq&menu=yes" title="qq">qq</a>
			        
						<a class="weibo" target="_blank" href="https://weibo.com/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-redis学习之路" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/08/14/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" class="article-date">
  	<time datetime="2020-08-14T15:21:33.000Z" itemprop="datePublished">2020-08-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis学习之路
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>
	</div>

        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、介绍一下Redis"><a href="#一、介绍一下Redis" class="headerlink" title="一、介绍一下Redis"></a>一、介绍一下Redis</h2><p>Redis是一个开源的，基于内存的数据结构存储，可用作于数据库、缓存、消息中间件。</p>
<ul>
<li><p>从官方的解释上，我们可以知道：Redis是基于内存，支持多种数据结构。</p>
</li>
<li><p>从经验的角度上，我们可以知道：Redis常用作于缓存。</p>
</li>
</ul>
<p>就我个人认为：学习一种新技术，先把握该技术整体的知识(思想)，再扣细节，这样学习起来会比较轻松一些。所以我们先以“内存”、“数据结构”、“缓存”来对Redis入门。</p>
<h3 id="1-1为什么要用Redis？"><a href="#1-1为什么要用Redis？" class="headerlink" title="1.1为什么要用Redis？"></a>1.1为什么要用Redis？</h3><p>我们可以发现这不就是Java的Map容器所拥有的特性吗，那为什么还需要Redis呢？</p>
<ul>
<li><p>Java实现的Map是本地缓存，如果有多台实例(机器)的话，每个实例都需要各自保存一份缓存，缓存不具有一致性</p>
</li>
<li><p>Redis实现的是分布式缓存，如果有多台实例(机器)的话，每个实例都共享一份缓存，缓存具有一致性。</p>
</li>
<li><p>Java实现的Map不是专业做缓存的，JVM内存太大容易挂掉的。一般用做于容器来存储临时数据，缓存的数据随着JVM销毁而结束。Map所存储的数据结构，缓存过期机制等等是需要程序员自己手写的。</p>
</li>
<li><p>Redis是专业做缓存的，可以用几十个G内存来做缓存。Redis一般用作于缓存，可以将缓存数据保存在硬盘中，Redis重启了后可以将其恢复。原生提供丰富的数据结构、缓存过期机制等等简单好用的功能。</p>
</li>
</ul>
<h3 id="1-2为什么要用缓存？"><a href="#1-2为什么要用缓存？" class="headerlink" title="1.2为什么要用缓存？"></a>1.2为什么要用缓存？</h3><p>如果我们的网站出现了性能问题(访问时间慢)，按经验来说，一般是由于数据库撑不住了。因为一般数据库的读写都是要经过磁盘的，而磁盘的速度可以说是相当慢的(相对内存来说)</p>
<h2 id="二、Redis的数据结构"><a href="#二、Redis的数据结构" class="headerlink" title="二、Redis的数据结构"></a>二、Redis的数据结构</h2><ul>
<li><p>Redis 命令参考：<a target="_blank" rel="noopener" href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p>
</li>
<li><p>try Redis(不用安装Redis即可体验Redis命令)：<a target="_blank" rel="noopener" href="http://try.redis.io/">http://try.redis.io/</a></p>
</li>
</ul>
<p>Redis支持丰富的数据结构，常用的有string、list、hash、set、sortset这几种。学习这些数据结构是使用Redis的基础！</p>
<p>“Redis is written in ANSI C”–&gt;Redis由C语言编写</p>
<p>首先还是得声明一下，Redis的存储是以key-value的形式的。Redis中的key一定是字符串，value可以是string、list、hash、set、sortset这几种常用的</p>
<p>但要值得注意的是：Redis并没有直接使用这些数据结构来实现key-value数据库，而是基于这些数据结构创建了一个对象系统。</p>
<ul>
<li>简单来说：Redis使用对象来表示数据库中的键和值。每次我们在Redis数据库中新创建一个键值对时，至少会创建出两个对象。一个是键对象，一个是值对象。</li>
</ul>
<p>Redis中的每个对象都由一个redisObject结构来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对象的类型</span><br><span class="line">    unsigned type 4:;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对象的编码格式</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向底层实现数据结构的指针</span><br><span class="line">    void * ptr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;.....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>

<p>简单来说就是Redis对key-value封装成对象，key是一个对象，value也是一个对象。每个对象都有type(类型)、encoding(编码)、ptr(指向底层数据结构的指针)来表示。</p>
<h3 id="2-1SDS简单动态字符串"><a href="#2-1SDS简单动态字符串" class="headerlink" title="2.1SDS简单动态字符串"></a>2.1SDS简单动态字符串</h3><p>Redis中的字符串跟C语言中的字符串，是有点差距的。</p>
<p>Redis使用sdshdr结构来表示一个SDS值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录buf数组中已使用的字节数量，也是字符串的长度</span><br><span class="line">    int len;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录buf数组未使用的字节数量</span><br><span class="line">    int free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="使用SDS的好处"><a href="#使用SDS的好处" class="headerlink" title="使用SDS的好处"></a>使用SDS的好处</h3></li>
</ul>
<p>1.sdshdr数据结构中用len属性记录了字符串的长度。那么获取字符串的长度时，时间复杂度只需要O(1)。</p>
<p>2.SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(内部实现了动态扩展机制)。</p>
<p>3.SDS可以减少内存分配的次数(空间预分配机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(free 属性)。</p>
<p>4.SDS是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。</p>
<h3 id="2-2链表"><a href="#2-2链表" class="headerlink" title="2.2链表"></a>2.2链表</h3><p>使用listNode结构来表示每个节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef strcut listNode&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前置节点</span><br><span class="line">    strcut listNode  *pre;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;后置节点</span><br><span class="line">    strcut listNode  *pre;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;节点的值</span><br><span class="line">    void  *value;</span><br><span class="line"></span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure>

<p>使用listNode是可以组成链表了，Redis中使用list结构来持有链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;表头结点</span><br><span class="line">    listNode  *head;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;表尾节点</span><br><span class="line">    listNode  *tail;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;链表长度</span><br><span class="line">    unsigned long len;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;节点值复制函数</span><br><span class="line">    void *(*dup) (viod *ptr);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;节点值释放函数</span><br><span class="line">    void  (*free) (viod *ptr);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;节点值对比函数</span><br><span class="line">    int (*match) (void *ptr,void *key);</span><br><span class="line"></span><br><span class="line">&#125;list</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1Redis链表的特性"><a href="#2-2-1Redis链表的特性" class="headerlink" title="2.2.1Redis链表的特性"></a>2.2.1Redis链表的特性</h4><p>   Redis的链表有以下特性：</p>
<ul>
<li><p>无环双向链表</p>
</li>
<li><p>获取表头指针，表尾指针，链表节点长度的时间复杂度均为O(1)</p>
</li>
<li><p>链表使用void *指针来保存节点值，可以保存各种不同类型的值</p>
</li>
</ul>
<h3 id="2-3哈希表"><a href="#2-3哈希表" class="headerlink" title="2.3哈希表"></a>2.3哈希表</h3><p>在Redis中，key-value的数据结构底层就是哈希表来实现的。对于哈希表来说，我们也并不陌生。在Java中，哈希表实际上就是数组+链表的形式来构建的。下面我们来看看Redis的哈希表是怎么构建的吧。</p>
<p>在Redis里边，哈希表使用dictht结构来定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;哈希表数组</span><br><span class="line">    dictEntry **table;  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;哈希表大小</span><br><span class="line">    unsigned long size;    </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;哈希表大小掩码，用于计算索引值</span><br><span class="line">    &#x2F;&#x2F;总是等于size-1</span><br><span class="line">    unsigned long sizemark;     </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;哈希表已有节点数量</span><br><span class="line">    unsigned long used;</span><br><span class="line"></span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure>

<p>我们下面继续写看看哈希表的节点是怎么实现的吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;键</span><br><span class="line">    void *key;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *value;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;    </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;指向下个哈希节点，组成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<p>从结构上看，我们可以发现：Redis实现的哈希表和Java中实现的是类似的。只不过Redis多了几个属性来记录常用的值：sizemark(掩码)、used(已有的节点数量)、size(大小)。</p>
<p>同样地，Redis为了更好的操作，对哈希表往上再封装了一层(参考上面的Redis实现链表)，使用dict结构来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;rehash索引</span><br><span class="line">    &#x2F;&#x2F;当rehash不进行时，值为-1</span><br><span class="line">    int rehashidx;  </span><br><span class="line"></span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-----------------------------------</span><br><span class="line"></span><br><span class="line">typedef struct dictType&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void * key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;复制键的函数</span><br><span class="line">    void *(*keyDup)(void *private, const void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;复制值得函数</span><br><span class="line">    void *(*valDup)(void *private, const void *obj);  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata , const void *key1, const void *key2)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *private, void *key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *private, void *obj);  </span><br><span class="line"></span><br><span class="line">&#125;dictType</span><br></pre></td></tr></table></figure>

<p>从代码实现和示例图上我们可以发现，Redis中有两个哈希表：</p>
<ul>
<li><p>ht[0]：用于存放真实的key-vlaue数据</p>
</li>
<li><p>ht[1]：用于扩容(rehash)</p>
</li>
</ul>
<p>Redis中哈希算法和哈希冲突跟Java实现的差不多，它俩差异就是：</p>
<ul>
<li><p>Redis哈希冲突时：是将新节点添加在链表的表头。</p>
</li>
<li><p>JDK1.8后，Java在哈希冲突时：是将新的节点添加到链表的表尾。</p>
</li>
</ul>
<h4 id="2-3-1rehash的过程"><a href="#2-3-1rehash的过程" class="headerlink" title="2.3.1rehash的过程"></a>2.3.1rehash的过程</h4><p>下面来具体讲讲Redis是怎么rehash的，因为我们从上面可以明显地看到，Redis是专门使用一个哈希表来做rehash的。这跟Java一次性直接rehash是有区别的。</p>
<p>在对哈希表进行扩展或者收缩操作时，reash过程并不是一次性地完成的，而是渐进式地完成的。</p>
<p>Redis在rehash时采取渐进式的原因：数据量如果过大的话，一次性rehash会有庞大的计算量，这很可能导致服务器一段时间内停止服务。</p>
<p>Redis具体是rehash时这么干的：</p>
<ul>
<li><p>(1:在字典中维持一个索引计数器变量rehashidx，并将设置为0，表示rehash开始。</p>
</li>
<li><p>(2:在rehash期间每次对字典进行增加、查询、删除和更新操作时，除了执行指定命令外；还会将ht[0]中rehashidx索引上的值rehash到ht[1]，操作完成后rehashidx+1。</p>
</li>
<li><p>(3:字典操作不断执行，最终在某个时间点，所有的键值对完成rehash，这时将rehashidx设置为-1，表示rehash完成</p>
</li>
<li><p>(4:在渐进式rehash过程中，字典会同时使用两个哈希表ht[0]和ht[1]，所有的更新、删除、查找操作也会在两个哈希表进行。例如要查找一个键的话，服务器会优先查找ht[0]，如果不存在，再查找ht[1]，诸如此类。此外当执行新增操作时，新的键值对一律保存到ht[1]，不再对ht[0]进行任何操作，以保证ht[0]的键值对数量只减不增，直至变为空表。</p>
</li>
</ul>
<h3 id="2-4跳跃表-shiplist"><a href="#2-4跳跃表-shiplist" class="headerlink" title="2.4跳跃表(shiplist)"></a>2.4跳跃表(shiplist)</h3><p>跳跃表(shiplist)是实现sortset(有序集合)的底层数据结构之一！</p>
<p>跳跃表可能对于大部分人来说不太常见，之前我在学习的时候发现了一篇不错的文章讲跳跃表的，建议大家先去看完下文再继续回来阅读：</p>
<ul>
<li>漫画算法：什么是跳跃表？<a target="_blank" rel="noopener" href="http://blog.jobbole.com/111731/">http://blog.jobbole.com/111731/</a></li>
</ul>
<p>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成。其中zskiplist保存跳跃表的信息(表头，表尾节点，长度)，zskiplistNode则表示跳跃表的节点。</p>
<p>按照惯例，我们来看看zskiplistNode跳跃表节点的结构是怎么样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typeof struct zskiplistNode &#123;</span><br><span class="line">        &#x2F;&#x2F; 后退指针</span><br><span class="line">        struct zskiplistNode *backward;</span><br><span class="line">        &#x2F;&#x2F; 分值</span><br><span class="line">        double score;</span><br><span class="line">        &#x2F;&#x2F; 成员对象</span><br><span class="line">        robj *obj;</span><br><span class="line">        &#x2F;&#x2F; 层</span><br><span class="line">        struct zskiplistLevel &#123;</span><br><span class="line">                &#x2F;&#x2F; 前进指针</span><br><span class="line">                struct zskiplistNode *forward;</span><br><span class="line">                &#x2F;&#x2F; 跨度</span><br><span class="line">                unsigned int span;</span><br><span class="line">        &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>zskiplist的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof struct zskiplist &#123;</span><br><span class="line">        &#x2F;&#x2F; 表头节点，表尾节点</span><br><span class="line">        struct skiplistNode *header,*tail;</span><br><span class="line">        &#x2F;&#x2F; 表中节点数量</span><br><span class="line">        unsigned long length;</span><br><span class="line">        &#x2F;&#x2F; 表中最大层数</span><br><span class="line">        int level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h3 id="2-5整数集合-intset"><a href="#2-5整数集合-intset" class="headerlink" title="2.5整数集合(intset)"></a>2.5整数集合(intset)</h3><p>整数集合是set(集合)的底层数据结构之一。当一个set(集合)只包含整数值元素，并且元素的数量不多时，Redis就会采用整数集合(intset)作为set(集合)的底层实现。</p>
<p>整数集合(intset)保证了元素是不会出现重复的，并且是有序的(从小到大排序)，intset的结构是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof struct intset &#123;</span><br><span class="line">        &#x2F;&#x2F; 编码方式</span><br><span class="line">        unit32_t encoding;</span><br><span class="line">        &#x2F;&#x2F; 集合包含的元素数量</span><br><span class="line">        unit32_t lenght;</span><br><span class="line">        &#x2F;&#x2F; 保存元素的数组</span><br><span class="line">        int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>说明：虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值：</p>
<p>INTSET_ENC_INT16</p>
<p>INTSET_ENC_INT32</p>
<p>INTSET_ENC_INT64</p>
<p>从编码格式的名字我们就可以知道，16,32,64编码对应能存放的数字范围是不一样的。16明显最少，64明显最大。</p>
<p>如果本来是INTSET_ENC_INT16的编码，想要存放大于INTSET_ENC_INT16编码能存放的整数值，此时就得编码升级(从16升级成32或者64)。步骤如下：</p>
<ul>
<li><p>1）根据新元素类型拓展整数集合底层数组的空间并为新元素分配空间。</p>
</li>
<li><p>2）将底层数组现有的所以元素都转换成与新元素相同的类型，并将类型转换后的元素放到正确的位上，需要维持底层数组的有序性质不变。</p>
</li>
<li><p>3）将新元素添加到底层数组。</p>
</li>
</ul>
<p>另外一提：只支持升级操作，并不支持降级操作。</p>
<h3 id="2-6压缩列表-ziplist"><a href="#2-6压缩列表-ziplist" class="headerlink" title="2.6压缩列表(ziplist)"></a>2.6压缩列表(ziplist)</h3><p>压缩列表(ziplist)是list和hash的底层实现之一。如果list的每个都是小整数值，或者是比较短的字符串，压缩列表(ziplist)作为list的底层实现。</p>
<p>压缩列表(ziplist)是Redis为了节约内存而开发的，是由一系列的特殊编码的连续内存块组成的顺序性数据结构。</p>
<p>压缩列表从表尾节点倒序遍历，首先指针通过zltail偏移量指向表尾节点，然后通过指向节点记录的前一个节点的长度依次向前遍历访问整个压缩列表。</p>
<h2 id="三、Redis中数据结构的对象"><a href="#三、Redis中数据结构的对象" class="headerlink" title="三、Redis中数据结构的对象"></a>三、Redis中数据结构的对象</h2><h3 id="3-1字符串-stirng-对象"><a href="#3-1字符串-stirng-对象" class="headerlink" title="3.1字符串(stirng)对象"></a>3.1字符串(stirng)对象</h3><p>在上面的图我们知道string类型有三种编码格式：</p>
<ul>
<li>int：整数值，这个整数值可以使用long类型来表示</li>
</ul>
<p>如果是浮点数，那就用embstr或者raw编码。具体用哪个就看这个数的长度了</p>
<ul>
<li><p>embstr：字符串值，这个字符串值的长度小于32字节</p>
</li>
<li><p>raw：字符串值，这个字符串值的长度大于32字节</p>
</li>
</ul>
<p>embstr和raw的区别：</p>
<ul>
<li><p>raw分配内存和释放内存的次数是两次，embstr是一次</p>
</li>
<li><p>embstr编码的数据保存在一块连续的内存里面</p>
</li>
</ul>
<p>编码之间的转换：</p>
<ul>
<li><p>int类型如果存的不再是一个整数值，则会从int转成raw</p>
</li>
<li><p>embstr是只读的，在修改的时候回从embstr转成raw</p>
</li>
</ul>
<h3 id="3-2列表-list-对象"><a href="#3-2列表-list-对象" class="headerlink" title="3.2列表(list)对象"></a>3.2列表(list)对象</h3><p>在上面的图我们知道list类型有两种编码格式：</p>
<ul>
<li>ziplist：字符串元素的长度都小于64个字节&amp;&amp;总数量少于512个</li>
</ul>
<ul>
<li>linkedlist：字符串元素的长度大于64个字节||总数量大于512个</li>
</ul>
<h3 id="3-3哈希-hash-对象"><a href="#3-3哈希-hash-对象" class="headerlink" title="3.3哈希(hash)对象"></a>3.3哈希(hash)对象</h3><p>在上面的图我们知道hash类型有两种编码格式：</p>
<ul>
<li><p>ziplist：key和value的字符串长度都小于64字节&amp;&amp;键值对总数量小于512</p>
</li>
<li><p>hashtable：key和value的字符串长度大于64字节||键值对总数量大于512</p>
</li>
</ul>
<h3 id="3-4集合-set-对象"><a href="#3-4集合-set-对象" class="headerlink" title="3.4集合(set)对象"></a>3.4集合(set)对象</h3><p>在上面的图我们知道set类型有两种编码格式：</p>
<ul>
<li><p>intset：保存的元素全都是整数&amp;&amp;总数量小于512</p>
</li>
<li><p>hashtable：保存的元素不是整数||总数量大于512</p>
</li>
</ul>
<h2 id="3-5有序集合-sortset-对象"><a href="#3-5有序集合-sortset-对象" class="headerlink" title="3.5有序集合(sortset)对象"></a>3.5有序集合(sortset)对象</h2><p>在上面的图我们知道set类型有两种编码格式：</p>
<ul>
<li><p>ziplist：元素长度小于64&amp;&amp;总数量小于128</p>
</li>
<li><p>skiplist：元素长度大于64||总数量大于128</p>
</li>
</ul>
<p>有序集合(sortset)对象同时采用skiplist和哈希表来实现：</p>
<ul>
<li>skiplist能够达到插入的时间复杂度为O(logn)，根据成员查分值的时间复杂度为O(1)</li>
</ul>
<p>编码之间的转换：</p>
<ul>
<li>原本是ziplist编码的，如果保存的数据长度大于64或者元素数量大于128，会转换成skiplist编码的。</li>
</ul>
<h3 id="3-6Redis对象一些细节"><a href="#3-6Redis对象一些细节" class="headerlink" title="3.6Redis对象一些细节"></a>3.6Redis对象一些细节</h3><ul>
<li>(1：服务器在执行某些命令的时候，会先检查给定的键的类型能否执行指定的命令。</li>
</ul>
<p>比如我们的数据结构是sortset，但你使用了list的命令。这是不对的，服务器会检查一下我们的数据结构是什么才会进一步执行命令</p>
<ul>
<li>(2：Redis的对象系统带有引用计数实现的内存回收机制。</li>
</ul>
<p>对象不再被使用的时候，对象所占用的内存会释放掉</p>
<ul>
<li><p>(3：Redis会共享值为0到9999的字符串对象</p>
</li>
<li><p>(4：对象会记录自己的最后一次被访问时间，这个时间可以用于计算对象的空转时间。</p>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文主要讲了一下Redis常用的数据结构，以及这些数据结构的底层设计是怎么样的。</p>
<p>至于我们在使用的时候挑选哪些数据结构作为存储，可以简单看看：</p>
<ul>
<li><p>string–&gt;简单的key-value</p>
</li>
<li><p>list–&gt;有序列表(底层是双向链表)–&gt;可做简单队列</p>
</li>
<li><p>set–&gt;无序列表(去重)–&gt;提供一系列的交集、并集、差集的命令</p>
</li>
<li><p>hash–&gt;哈希表–&gt;存储结构化数据</p>
</li>
<li><p>sortset–&gt;有序集合映射(member-score)–&gt;排行榜</p>
</li>
</ul>
<p>本文转载自java3y</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/17/redis%E5%AD%A6%E4%B9%A02/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Redis学习2
        
      </div>
    </a>
  
  
    <a href="/2020/08/13/%E6%B3%9B%E5%9E%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">泛型</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="redis学习之路" data-title="Redis学习之路" data-url="http://www.2333nmsl.ml/2020/08/14/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"  data-images="/img/1.gif" data-content="Redis学习之路">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 yht
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"rect":"opacity:0.8","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>